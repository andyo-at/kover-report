<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/action.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/action.ts" />
              <option name="originalContent" value="import * as actionsCore from '@actions/core'&#10;import * as actionsGithub from '@actions/github'&#10;import {createComment} from './render'&#10;import {getFileCoverage, getOverallCoverage, parseReport} from './reader'&#10;import {&#10;  ChangedFile,&#10;  ChangedFilesCoverage,&#10;  CounterType,&#10;  Coverage&#10;} from './types.d'&#10;&#10;export const run = async (&#10;  core: typeof actionsCore,&#10;  github: typeof actionsGithub&#10;): Promise&lt;void&gt; =&gt; {&#10;  const paths: string[] = core.getMultilineInput('path', {required: true})&#10;  const token = core.getInput('token', {required: true})&#10;  const titleInput = core.getInput('title', {required: false})&#10;  const title = titleInput !== '' ? titleInput : undefined&#10;  const updateComment =&#10;    core.getInput('update-comment', {required: false}) === 'true'&#10;  const minCoverageOverallInput = core.getInput('min-coverage-overall', {&#10;    required: false&#10;  })&#10;  const minCoverageOverall =&#10;    minCoverageOverallInput !== ''&#10;      ? parseFloat(minCoverageOverallInput)&#10;      : undefined&#10;  const minCoverageChangedFilesInput = core.getInput(&#10;    'min-coverage-changed-files',&#10;    {&#10;      required: false&#10;    }&#10;  )&#10;  const minCoverageChangedFiles =&#10;    minCoverageChangedFilesInput !== ''&#10;      ? parseFloat(minCoverageChangedFilesInput)&#10;      : undefined&#10;  const counterTypeInput = core.getInput('coverage-counter-type', {&#10;    required: false&#10;  })&#10;  const counterType = (&#10;    counterTypeInput !== '' ? counterTypeInput : 'LINE'&#10;  ) as CounterType&#10;&#10;  const octokit = github.getOctokit(token)&#10;  const event = github.context.eventName&#10;  core.info(`Event is ${event}`)&#10;&#10;  if (paths.length === 0) {&#10;    throw Error('At least one path must be provided')&#10;  }&#10;&#10;  const details = getDetails(event, github.context.payload)&#10;&#10;  const changedFiles = await getChangedFiles(&#10;    details.base,&#10;    details.head,&#10;    octokit,&#10;    github.context.repo&#10;  )&#10;&#10;  const overallCoverage: Coverage = {&#10;    missed: 0,&#10;    covered: 0,&#10;    percentage: 0&#10;  }&#10;  const overallFilesCoverage: ChangedFilesCoverage = {&#10;    percentage: 0,&#10;    files: []&#10;  }&#10;&#10;  const totalReports = paths.length&#10;  for (const path of paths) {&#10;    const report = await parseReport(path)&#10;    if (!report) {&#10;      throw Error(`No Kover report detected in path ${path}`)&#10;    }&#10;&#10;    const reportsCoverage = getOverallCoverage(report, counterType)&#10;    overallCoverage.missed += reportsCoverage?.missed ?? 0&#10;    overallCoverage.covered += reportsCoverage?.covered ?? 0&#10;    overallCoverage.percentage += reportsCoverage?.percentage ?? 0&#10;&#10;    const reportsFilesCovered = getFileCoverage(&#10;      report,&#10;      changedFiles,&#10;      counterType&#10;    )&#10;    overallFilesCoverage.percentage += reportsFilesCovered.percentage&#10;    overallFilesCoverage.files = overallFilesCoverage.files.concat(&#10;      reportsFilesCovered.files&#10;    )&#10;  }&#10;&#10;  overallCoverage.percentage = overallCoverage.percentage / totalReports&#10;  overallFilesCoverage.percentage =&#10;    overallFilesCoverage.percentage / totalReports&#10;&#10;  if (!overallCoverage) {&#10;    throw Error('No project coverage detected')&#10;  }&#10;  core.setOutput('coverage-overall', overallCoverage.percentage)&#10;  core.setOutput('coverage-changed-files', overallFilesCoverage.percentage)&#10;&#10;  const comment = createComment(&#10;    title,&#10;    overallCoverage,&#10;    overallFilesCoverage,&#10;    minCoverageOverall,&#10;    minCoverageChangedFiles&#10;  )&#10;&#10;  if (details.prNumber != null) {&#10;    await addComment(&#10;      details.prNumber,&#10;      title,&#10;      comment,&#10;      updateComment,&#10;      octokit,&#10;      github.context.repo&#10;    )&#10;  }&#10;}&#10;&#10;export const getDetails = (&#10;  event: string,&#10;  payload: typeof actionsGithub.context.payload&#10;): {prNumber: number | null; base: string; head: string} =&gt; {&#10;  switch (event) {&#10;    case 'pull_request':&#10;    case 'pull_request_target':&#10;      return {&#10;        prNumber: payload.pull_request?.number ?? null,&#10;        base: payload.pull_request?.base.sha,&#10;        head: payload.pull_request?.head.sha&#10;      }&#10;    case 'push':&#10;      return {&#10;        prNumber: null,&#10;        base: payload.before,&#10;        head: payload.after&#10;      }&#10;    default:&#10;      throw Error(&#10;        `Only pull requests and pushes are supported, ${event} not supported.`&#10;      )&#10;  }&#10;}&#10;&#10;export const addComment = async (&#10;  prNumber: number,&#10;  title: string | undefined,&#10;  body: string,&#10;  updateComment: boolean,&#10;  client: ReturnType&lt;typeof actionsGithub.getOctokit&gt;,&#10;  repo: typeof actionsGithub.context.repo&#10;): Promise&lt;void&gt; =&gt; {&#10;  let commentUpdated = false&#10;&#10;  if (title &amp;&amp; updateComment) {&#10;    const comments = await client.rest.issues.listComments({&#10;      issue_number: prNumber,&#10;      ...repo&#10;    })&#10;    const comment = comments.data.find(&#10;      c =&gt; c.body?.startsWith(`### ${title}`) ?? false&#10;    )&#10;&#10;    if (comment) {&#10;      await client.rest.issues.updateComment({&#10;        comment_id: comment.id,&#10;        body,&#10;        ...repo&#10;      })&#10;      commentUpdated = true&#10;    }&#10;  }&#10;&#10;  if (!commentUpdated) {&#10;    await client.rest.issues.createComment({&#10;      issue_number: prNumber,&#10;      body,&#10;      ...repo&#10;    })&#10;  }&#10;}&#10;&#10;export const getChangedFiles = async (&#10;  base: string,&#10;  head: string,&#10;  client: ReturnType&lt;typeof actionsGithub.getOctokit&gt;,&#10;  repo: typeof actionsGithub.context.repo&#10;): Promise&lt;ChangedFile[]&gt; =&gt; {&#10;  const response = await client.rest.repos.compareCommits({&#10;    base,&#10;    head,&#10;    ...repo&#10;  })&#10;&#10;  return (&#10;    response.data.files?.map(file =&gt; ({&#10;      filePath: file.filename,&#10;      url: file.blob_url&#10;    })) ?? []&#10;  )&#10;}&#10;" />
              <option name="updatedContent" value="import * as actionsCore from '@actions/core'&#10;import * as actionsGithub from '@actions/github'&#10;import {createComment} from './render'&#10;import {getFileCoverage, getOverallCoverage, parseReport} from './reader'&#10;import {&#10;  ChangedFile,&#10;  ChangedFilesCoverage,&#10;  CounterType,&#10;  Coverage&#10;} from './types.d'&#10;&#10;export const run = async (&#10;  core: typeof actionsCore,&#10;  github: typeof actionsGithub&#10;): Promise&lt;void&gt; =&gt; {&#10;  const paths: string[] = core.getMultilineInput('path', {required: true})&#10;  const token = core.getInput('token', {required: true})&#10;  const titleInput = core.getInput('title', {required: false})&#10;  const title = titleInput !== '' ? titleInput : undefined&#10;  const updateComment =&#10;    core.getInput('update-comment', {required: false}) === 'true'&#10;  const minCoverageOverallInput = core.getInput('min-coverage-overall', {&#10;    required: false&#10;  })&#10;  const minCoverageOverall =&#10;    minCoverageOverallInput !== ''&#10;      ? parseFloat(minCoverageOverallInput)&#10;      : undefined&#10;  const minCoverageChangedFilesInput = core.getInput(&#10;    'min-coverage-changed-files',&#10;    {&#10;      required: false&#10;    }&#10;  )&#10;  const minCoverageChangedFiles =&#10;    minCoverageChangedFilesInput !== ''&#10;      ? parseFloat(minCoverageChangedFilesInput)&#10;      : undefined&#10;  const counterTypeInput = core.getInput('coverage-counter-type', {&#10;    required: false&#10;  })&#10;  const counterType = (&#10;    counterTypeInput !== '' ? counterTypeInput : 'LINE'&#10;  ) as CounterType&#10;&#10;  const octokit = github.getOctokit(token)&#10;  const event = github.context.eventName&#10;  core.info(`Event is ${event}`)&#10;&#10;  if (paths.length === 0) {&#10;    throw Error('At least one path must be provided')&#10;  }&#10;&#10;  const details = getDetails(event, github.context.payload)&#10;&#10;  const changedFiles = await getChangedFiles(&#10;    details.base,&#10;    details.head,&#10;    octokit,&#10;    github.context.repo&#10;  )&#10;&#10;  const overallCoverage: Coverage = {&#10;    missed: 0,&#10;    covered: 0,&#10;    percentage: 0&#10;  }&#10;  const overallFilesCoverage: ChangedFilesCoverage = {&#10;    percentage: 0,&#10;    files: []&#10;  }&#10;&#10;  const totalReports = paths.length&#10;  for (const path of paths) {&#10;    const report = await parseReport(path)&#10;    if (!report) {&#10;      throw Error(`No Kover report detected in path ${path}`)&#10;    }&#10;&#10;    const reportsCoverage = getOverallCoverage(report, counterType)&#10;    overallCoverage.missed += reportsCoverage?.missed ?? 0&#10;    overallCoverage.covered += reportsCoverage?.covered ?? 0&#10;&#10;    const reportsFilesCovered = getFileCoverage(&#10;      report,&#10;      changedFiles,&#10;      counterType&#10;    )&#10;    overallFilesCoverage.percentage += reportsFilesCovered.percentage&#10;    overallFilesCoverage.files = overallFilesCoverage.files.concat(&#10;      reportsFilesCovered.files&#10;    )&#10;  }&#10;&#10;  if (overallCoverage.covered + overallCoverage.missed &gt; 0) {&#10;    overallCoverage.percentage = parseFloat(&#10;      (&#10;        (overallCoverage.covered / (overallCoverage.covered + overallCoverage.missed)) *&#10;        100&#10;      ).toFixed(2)&#10;    )&#10;  } else {&#10;    overallCoverage.percentage = 0&#10;  }&#10;  overallFilesCoverage.percentage =&#10;    overallFilesCoverage.percentage / totalReports&#10;&#10;  if (!overallCoverage) {&#10;    throw Error('No project coverage detected')&#10;  }&#10;  core.setOutput('coverage-overall', overallCoverage.percentage)&#10;  core.setOutput('coverage-changed-files', overallFilesCoverage.percentage)&#10;&#10;  const comment = createComment(&#10;    title,&#10;    overallCoverage,&#10;    overallFilesCoverage,&#10;    minCoverageOverall,&#10;    minCoverageChangedFiles&#10;  )&#10;&#10;  if (details.prNumber != null) {&#10;    await addComment(&#10;      details.prNumber,&#10;      title,&#10;      comment,&#10;      updateComment,&#10;      octokit,&#10;      github.context.repo&#10;    )&#10;  }&#10;}&#10;&#10;export const getDetails = (&#10;  event: string,&#10;  payload: typeof actionsGithub.context.payload&#10;): {prNumber: number | null; base: string; head: string} =&gt; {&#10;  switch (event) {&#10;    case 'pull_request':&#10;    case 'pull_request_target':&#10;      return {&#10;        prNumber: payload.pull_request?.number ?? null,&#10;        base: payload.pull_request?.base.sha,&#10;        head: payload.pull_request?.head.sha&#10;      }&#10;    case 'push':&#10;      return {&#10;        prNumber: null,&#10;        base: payload.before,&#10;        head: payload.after&#10;      }&#10;    default:&#10;      throw Error(&#10;        `Only pull requests and pushes are supported, ${event} not supported.`&#10;      )&#10;  }&#10;}&#10;&#10;export const addComment = async (&#10;  prNumber: number,&#10;  title: string | undefined,&#10;  body: string,&#10;  updateComment: boolean,&#10;  client: ReturnType&lt;typeof actionsGithub.getOctokit&gt;,&#10;  repo: typeof actionsGithub.context.repo&#10;): Promise&lt;void&gt; =&gt; {&#10;  let commentUpdated = false&#10;&#10;  if (title &amp;&amp; updateComment) {&#10;    const comments = await client.rest.issues.listComments({&#10;      issue_number: prNumber,&#10;      ...repo&#10;    })&#10;    const comment = comments.data.find(&#10;      c =&gt; c.body?.startsWith(`### ${title}`) ?? false&#10;    )&#10;&#10;    if (comment) {&#10;      await client.rest.issues.updateComment({&#10;        comment_id: comment.id,&#10;        body,&#10;        ...repo&#10;      })&#10;      commentUpdated = true&#10;    }&#10;  }&#10;&#10;  if (!commentUpdated) {&#10;    await client.rest.issues.createComment({&#10;      issue_number: prNumber,&#10;      body,&#10;      ...repo&#10;    })&#10;  }&#10;}&#10;&#10;export const getChangedFiles = async (&#10;  base: string,&#10;  head: string,&#10;  client: ReturnType&lt;typeof actionsGithub.getOctokit&gt;,&#10;  repo: typeof actionsGithub.context.repo&#10;): Promise&lt;ChangedFile[]&gt; =&gt; {&#10;  const response = await client.rest.repos.compareCommits({&#10;    base,&#10;    head,&#10;    ...repo&#10;  })&#10;&#10;  return (&#10;    response.data.files?.map(file =&gt; ({&#10;      filePath: file.filename,&#10;      url: file.blob_url&#10;    })) ?? []&#10;  )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/action.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/action.test.ts" />
              <option name="originalContent" value="import {describe, test, expect, jest} from '@jest/globals'&#10;import {addComment, getChangedFiles, getDetails} from '../src/action'&#10;&#10;describe('Action functions', () =&gt; {&#10;  test('get changed files from context', async () =&gt; {&#10;    const compareCommitsMock = jest.fn(() =&gt;&#10;      Promise.resolve({&#10;        data: {&#10;          files: [&#10;            {filename: 'file1', blob_url: 'url1'},&#10;            {filename: 'file2', blob_url: 'url2'}&#10;          ]&#10;        }&#10;      })&#10;    )&#10;    const client = {&#10;      rest: {&#10;        repos: {&#10;          compareCommits: compareCommitsMock&#10;        }&#10;      }&#10;    } as any&#10;    const repo = {&#10;      owner: 'owner',&#10;      repo: 'repo'&#10;    }&#10;&#10;    const changedFiles = await getChangedFiles('base', 'head', client, repo)&#10;&#10;    expect(compareCommitsMock).toHaveBeenCalledWith({&#10;      base: 'base',&#10;      head: 'head',&#10;      ...repo&#10;    })&#10;    expect(changedFiles).toMatchObject([&#10;      {filePath: 'file1', url: 'url1'},&#10;      {filePath: 'file2', url: 'url2'}&#10;    ])&#10;  })&#10;&#10;  test('get changed files from context returns null', async () =&gt; {&#10;    const compareCommitsMock = jest.fn(() =&gt;&#10;      Promise.resolve({&#10;        data: {}&#10;      })&#10;    )&#10;    const client = {&#10;      rest: {&#10;        repos: {&#10;          compareCommits: compareCommitsMock&#10;        }&#10;      }&#10;    } as any&#10;    const repo = {&#10;      owner: 'owner',&#10;      repo: 'repo'&#10;    }&#10;&#10;    const changedFiles = await getChangedFiles('base', 'head', client, repo)&#10;&#10;    expect(compareCommitsMock).toHaveBeenCalledWith({&#10;      base: 'base',&#10;      head: 'head',&#10;      ...repo&#10;    })&#10;    expect(changedFiles.length).toBe(0)&#10;  })&#10;&#10;  test('get details from event payload for `pull_request`', () =&gt; {&#10;    const payload = {&#10;      pull_request: {&#10;        base: {sha: 'base_sha'},&#10;        head: {sha: 'head_sha'},&#10;        number: 12&#10;      }&#10;    } as any&#10;&#10;    const details = getDetails('pull_request', payload)&#10;&#10;    expect(details).toMatchObject({&#10;      prNumber: 12,&#10;      base: 'base_sha',&#10;      head: 'head_sha'&#10;    })&#10;  })&#10;&#10;  test('get details from event payload for `pull_request_target`', () =&gt; {&#10;    const payload = {&#10;      pull_request: {&#10;        base: {sha: 'base_sha'},&#10;        head: {sha: 'head_sha'}&#10;      }&#10;    } as any&#10;&#10;    const details = getDetails('pull_request_target', payload)&#10;&#10;    expect(details).toMatchObject({&#10;      prNumber: null,&#10;      base: 'base_sha',&#10;      head: 'head_sha'&#10;    })&#10;  })&#10;&#10;  test('get details from event payload for `push`', () =&gt; {&#10;    const payload = {&#10;      before: 'base_sha',&#10;      after: 'head_sha'&#10;    } as any&#10;&#10;    const details = getDetails('push', payload)&#10;&#10;    expect(details).toMatchObject({&#10;      prNumber: null,&#10;      base: 'base_sha',&#10;      head: 'head_sha'&#10;    })&#10;  })&#10;&#10;  test('get details from event payload throws for other event', () =&gt; {&#10;    const payload = {&#10;      before: 'base_sha',&#10;      after: 'head_sha'&#10;    } as any&#10;&#10;    expect(() =&gt; getDetails('rebase', payload)).toThrowError(&#10;      Error(&#10;        `Only pull requests and pushes are supported, rebase not supported.`&#10;      )&#10;    )&#10;  })&#10;&#10;  test('add comment without title', async () =&gt; {&#10;    const createCommentMock = jest.fn(() =&gt; Promise.resolve({}))&#10;    const client = {&#10;      rest: {&#10;        issues: {&#10;          createComment: createCommentMock&#10;        }&#10;      }&#10;    } as any&#10;    const repo = {&#10;      owner: 'owner',&#10;      repo: 'repo'&#10;    }&#10;    await addComment(12, undefined, 'body', false, client, repo)&#10;&#10;    expect(createCommentMock).toHaveBeenCalledWith({&#10;      issue_number: 12,&#10;      body: 'body',&#10;      ...repo&#10;    })&#10;  })&#10;&#10;  test('add comment with title updates existing comment', async () =&gt; {&#10;    const listCommentstMock = jest.fn(() =&gt;&#10;      Promise.resolve({data: [{body: '### title xyz', id: '#8'}]})&#10;    )&#10;    const updateCommentMock = jest.fn(() =&gt; Promise.resolve({}))&#10;    const client = {&#10;      rest: {&#10;        issues: {&#10;          listComments: listCommentstMock,&#10;          updateComment: updateCommentMock&#10;        }&#10;      }&#10;    } as any&#10;    const repo = {&#10;      owner: 'owner',&#10;      repo: 'repo'&#10;    }&#10;    await addComment(12, 'title', 'body', true, client, repo)&#10;&#10;    expect(listCommentstMock).toHaveBeenCalledWith({&#10;      issue_number: 12,&#10;      ...repo&#10;    })&#10;    expect(updateCommentMock).toHaveBeenCalledWith({&#10;      comment_id: '#8',&#10;      body: 'body',&#10;      ...repo&#10;    })&#10;  })&#10;&#10;  test('add comment with title creates new comment if no matching comment', async () =&gt; {&#10;    const listCommentstMock = jest.fn(() =&gt;&#10;      Promise.resolve({data: [{body: '### header xyz', id: '#8'}]})&#10;    )&#10;    const createCommentMock = jest.fn(() =&gt; Promise.resolve({}))&#10;    const client = {&#10;      rest: {&#10;        issues: {&#10;          listComments: listCommentstMock,&#10;          createComment: createCommentMock&#10;        }&#10;      }&#10;    } as any&#10;    const repo = {&#10;      owner: 'owner',&#10;      repo: 'repo'&#10;    }&#10;    await addComment(12, 'title', 'body', true, client, repo)&#10;&#10;    expect(listCommentstMock).toHaveBeenCalledWith({&#10;      issue_number: 12,&#10;      ...repo&#10;    })&#10;    expect(createCommentMock).toHaveBeenCalledWith({&#10;      issue_number: 12,&#10;      body: 'body',&#10;      ...repo&#10;    })&#10;  })&#10;&#10;  test('add comment with title creates new comment', async () =&gt; {&#10;    const createCommentMock = jest.fn(() =&gt; Promise.resolve({}))&#10;    const client = {&#10;      rest: {&#10;        issues: {&#10;          createComment: createCommentMock&#10;        }&#10;      }&#10;    } as any&#10;    const repo = {&#10;      owner: 'owner',&#10;      repo: 'repo'&#10;    }&#10;    await addComment(12, 'title', 'body', false, client, repo)&#10;&#10;    expect(createCommentMock).toHaveBeenCalledWith({&#10;      issue_number: 12,&#10;      body: 'body',&#10;      ...repo&#10;    })&#10;  })&#10;})&#10;" />
              <option name="updatedContent" value="import {describe, test, expect, jest} from '@jest/globals'&#10;import {addComment, getChangedFiles, getDetails, run} from '../src/action'&#10;import {Report} from '../src/types'&#10;import * as reader from '../src/reader'&#10;import * as render from '../src/render'&#10;&#10;describe('Action functions', () =&gt; {&#10;  test('get changed files from context', async () =&gt; {&#10;    const compareCommitsMock = jest.fn(() =&gt;&#10;      Promise.resolve({&#10;        data: {&#10;          files: [&#10;            {filename: 'file1', blob_url: 'url1'},&#10;            {filename: 'file2', blob_url: 'url2'}&#10;          ]&#10;        }&#10;      })&#10;    )&#10;    const client = {&#10;      rest: {&#10;        repos: {&#10;          compareCommits: compareCommitsMock&#10;        }&#10;      }&#10;    } as any&#10;    const repo = {&#10;      owner: 'owner',&#10;      repo: 'repo'&#10;    }&#10;&#10;    const changedFiles = await getChangedFiles('base', 'head', client, repo)&#10;&#10;    expect(compareCommitsMock).toHaveBeenCalledWith({&#10;      base: 'base',&#10;      head: 'head',&#10;      ...repo&#10;    })&#10;    expect(changedFiles).toMatchObject([&#10;      {filePath: 'file1', url: 'url1'},&#10;      {filePath: 'file2', url: 'url2'}&#10;    ])&#10;  })&#10;&#10;  test('get changed files from context returns null', async () =&gt; {&#10;    const compareCommitsMock = jest.fn(() =&gt;&#10;      Promise.resolve({&#10;        data: {}&#10;      })&#10;    )&#10;    const client = {&#10;      rest: {&#10;        repos: {&#10;          compareCommits: compareCommitsMock&#10;        }&#10;      }&#10;    } as any&#10;    const repo = {&#10;      owner: 'owner',&#10;      repo: 'repo'&#10;    }&#10;&#10;    const changedFiles = await getChangedFiles('base', 'head', client, repo)&#10;&#10;    expect(compareCommitsMock).toHaveBeenCalledWith({&#10;      base: 'base',&#10;      head: 'head',&#10;      ...repo&#10;    })&#10;    expect(changedFiles.length).toBe(0)&#10;  })&#10;&#10;  test('get details from event payload for `pull_request`', () =&gt; {&#10;    const payload = {&#10;      pull_request: {&#10;        base: {sha: 'base_sha'},&#10;        head: {sha: 'head_sha'},&#10;        number: 12&#10;      }&#10;    } as any&#10;&#10;    const details = getDetails('pull_request', payload)&#10;&#10;    expect(details).toMatchObject({&#10;      prNumber: 12,&#10;      base: 'base_sha',&#10;      head: 'head_sha'&#10;    })&#10;  })&#10;&#10;  test('get details from event payload for `pull_request_target`', () =&gt; {&#10;    const payload = {&#10;      pull_request: {&#10;        base: {sha: 'base_sha'},&#10;        head: {sha: 'head_sha'}&#10;      }&#10;    } as any&#10;&#10;    const details = getDetails('pull_request_target', payload)&#10;&#10;    expect(details).toMatchObject({&#10;      prNumber: null,&#10;      base: 'base_sha',&#10;      head: 'head_sha'&#10;    })&#10;  })&#10;&#10;  test('get details from event payload for `push`', () =&gt; {&#10;    const payload = {&#10;      before: 'base_sha',&#10;      after: 'head_sha'&#10;    } as any&#10;&#10;    const details = getDetails('push', payload)&#10;&#10;    expect(details).toMatchObject({&#10;      prNumber: null,&#10;      base: 'base_sha',&#10;      head: 'head_sha'&#10;    })&#10;  })&#10;&#10;  test('get details from event payload throws for other event', () =&gt; {&#10;    const payload = {&#10;      before: 'base_sha',&#10;      after: 'head_sha'&#10;    } as any&#10;&#10;    expect(() =&gt; getDetails('rebase', payload)).toThrowError(&#10;      Error(&#10;        `Only pull requests and pushes are supported, rebase not supported.`&#10;      )&#10;    )&#10;  })&#10;&#10;  test('add comment without title', async () =&gt; {&#10;    const createCommentMock = jest.fn(() =&gt; Promise.resolve({}))&#10;    const client = {&#10;      rest: {&#10;        issues: {&#10;          createComment: createCommentMock&#10;        }&#10;      }&#10;    } as any&#10;    const repo = {&#10;      owner: 'owner',&#10;      repo: 'repo'&#10;    }&#10;    await addComment(12, undefined, 'body', false, client, repo)&#10;&#10;    expect(createCommentMock).toHaveBeenCalledWith({&#10;      issue_number: 12,&#10;      body: 'body',&#10;      ...repo&#10;    })&#10;  })&#10;&#10;  test('add comment with title updates existing comment', async () =&gt; {&#10;    const listCommentstMock = jest.fn(() =&gt;&#10;      Promise.resolve({data: [{body: '### title xyz', id: '#8'}]})&#10;    )&#10;    const updateCommentMock = jest.fn(() =&gt; Promise.resolve({}))&#10;    const client = {&#10;      rest: {&#10;        issues: {&#10;          listComments: listCommentstMock,&#10;          updateComment: updateCommentMock&#10;        }&#10;      }&#10;    } as any&#10;    const repo = {&#10;      owner: 'owner',&#10;      repo: 'repo'&#10;    }&#10;    await addComment(12, 'title', 'body', true, client, repo)&#10;&#10;    expect(listCommentstMock).toHaveBeenCalledWith({&#10;      issue_number: 12,&#10;      ...repo&#10;    })&#10;    expect(updateCommentMock).toHaveBeenCalledWith({&#10;      comment_id: '#8',&#10;      body: 'body',&#10;      ...repo&#10;    })&#10;  })&#10;&#10;  test('add comment with title creates new comment if no matching comment', async () =&gt; {&#10;    const listCommentstMock = jest.fn(() =&gt;&#10;      Promise.resolve({data: [{body: '### header xyz', id: '#8'}]})&#10;    )&#10;    const createCommentMock = jest.fn(() =&gt; Promise.resolve({}))&#10;    const client = {&#10;      rest: {&#10;        issues: {&#10;          listComments: listCommentstMock,&#10;          createComment: createCommentMock&#10;        }&#10;      }&#10;    } as any&#10;    const repo = {&#10;      owner: 'owner',&#10;      repo: 'repo'&#10;    }&#10;    await addComment(12, 'title', 'body', true, client, repo)&#10;&#10;    expect(listCommentstMock).toHaveBeenCalledWith({&#10;      issue_number: 12,&#10;      ...repo&#10;    })&#10;    expect(createCommentMock).toHaveBeenCalledWith({&#10;      issue_number: 12,&#10;      body: 'body',&#10;      ...repo&#10;    })&#10;  })&#10;&#10;  test('add comment with title creates new comment', async () =&gt; {&#10;    const createCommentMock = jest.fn(() =&gt; Promise.resolve({}))&#10;    const client = {&#10;      rest: {&#10;        issues: {&#10;          createComment: createCommentMock&#10;        }&#10;      }&#10;    } as any&#10;    const repo = {&#10;      owner: 'owner',&#10;      repo: 'repo'&#10;    }&#10;    await addComment(12, 'title', 'body', false, client, repo)&#10;&#10;    expect(createCommentMock).toHaveBeenCalledWith({&#10;      issue_number: 12,&#10;      body: 'body',&#10;      ...repo&#10;    })&#10;  })&#10;&#10;  test('run handles reports without overall counters (NaN edge case)', async () =&gt; {&#10;    // Mock reports that don't have overall counters at report level (like bulk reports)&#10;    const reportWithoutOverallCounters: Report = {&#10;      report: {&#10;        $: {name: 'Module Report without overall counters'},&#10;        // No counter property at report level&#10;        package: [&#10;          {&#10;            $: {name: 'com/example/module'},&#10;            class: [],&#10;            sourcefile: [&#10;              {&#10;                $: {name: 'Example.kt'},&#10;                line: [],&#10;                counter: [&#10;                  {$: {type: 'LINE', missed: '10', covered: '20'}}&#10;                ]&#10;              }&#10;            ],&#10;            counter: [&#10;              {$: {type: 'LINE', missed: '10', covered: '20'}}&#10;            ]&#10;          }&#10;        ]&#10;      }&#10;    }&#10;&#10;    const reportWithOverallCounters: Report = {&#10;      report: {&#10;        $: {name: 'Module Report with overall counters'},&#10;        counter: [&#10;          {$: {type: 'LINE', missed: '5', covered: '15'}}&#10;        ],&#10;        package: []&#10;      }&#10;    }&#10;&#10;    // Mock the core and github objects&#10;    const mockCore = {&#10;      getMultilineInput: jest.fn().mockReturnValue(['/path/report1.xml', '/path/report2.xml']),&#10;      getInput: jest.fn().mockImplementation((key: string) =&gt; {&#10;        switch (key) {&#10;          case 'token': return 'mock-token'&#10;          case 'coverage-counter-type': return 'LINE'&#10;          default: return ''&#10;        }&#10;      }),&#10;      info: jest.fn(),&#10;      setOutput: jest.fn(),&#10;      setFailed: jest.fn()&#10;    } as any&#10;&#10;    const mockGithub = {&#10;      getOctokit: jest.fn().mockReturnValue({&#10;        rest: {&#10;          repos: {&#10;            compareCommits: jest.fn().mockResolvedValue({&#10;              data: { files: [] }&#10;            })&#10;          },&#10;          issues: {&#10;            createComment: jest.fn().mockResolvedValue({})&#10;          }&#10;        }&#10;      }),&#10;      context: {&#10;        eventName: 'pull_request',&#10;        payload: {&#10;          pull_request: {&#10;            number: 123,&#10;            base: { sha: 'base-sha' },&#10;            head: { sha: 'head-sha' }&#10;          }&#10;        },&#10;        repo: { owner: 'test-owner', repo: 'test-repo' }&#10;      }&#10;    } as any&#10;&#10;    // Mock parseReport to return our test reports&#10;    const parseReportSpy = jest.spyOn(reader, 'parseReport')&#10;      .mockResolvedValueOnce(reportWithoutOverallCounters)&#10;      .mockResolvedValueOnce(reportWithOverallCounters)&#10;&#10;    // Mock createComment to capture the result&#10;    const createCommentSpy = jest.spyOn(render, 'createComment')&#10;      .mockReturnValue('Mock comment')&#10;&#10;    await run(mockCore, mockGithub)&#10;&#10;    // Verify that setOutput was called with valid numbers (not NaN)&#10;    expect(mockCore.setOutput).toHaveBeenCalledWith('coverage-overall', expect.any(Number))&#10;    expect(mockCore.setOutput).toHaveBeenCalledWith('coverage-changed-files', expect.any(Number))&#10;&#10;    // Get the actual values that were set&#10;    const overallCoverageCall = mockCore.setOutput.mock.calls.find(call =&gt; call[0] === 'coverage-overall')&#10;    const changedFilesCoverageCall = mockCore.setOutput.mock.calls.find(call =&gt; call[0] === 'coverage-changed-files')&#10;&#10;    const overallCoverage = overallCoverageCall[1]&#10;    const changedFilesCoverage = changedFilesCoverageCall[1]&#10;&#10;    // Verify the values are not NaN and are correctly calculated&#10;    expect(Number.isNaN(overallCoverage)).toBe(false)&#10;    expect(Number.isNaN(changedFilesCoverage)).toBe(false)&#10;    &#10;    // Expected calculation: &#10;    // Report 1: no overall counters (missed: 0, covered: 0)&#10;    // Report 2: missed: 5, covered: 15&#10;    // Total: missed: 5, covered: 15 = 75% coverage&#10;    expect(overallCoverage).toBe(75)&#10;&#10;    // Verify createComment was called with valid coverage data&#10;    expect(createCommentSpy).toHaveBeenCalledWith(&#10;      undefined, // title&#10;      expect.objectContaining({&#10;        missed: 5,&#10;        covered: 15,&#10;        percentage: 75&#10;      }),&#10;      expect.any(Object), // overallFilesCoverage&#10;      undefined, // minCoverageOverall&#10;      undefined // minCoverageChangedFiles&#10;    )&#10;&#10;    // Clean up spies&#10;    parseReportSpy.mockRestore()&#10;    createCommentSpy.mockRestore()&#10;  })&#10;})" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>